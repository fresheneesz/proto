{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///proto.umd.js","webpack:///webpack/bootstrap 41a096fe40a15f5337f5","webpack:///./billysFile/code/javascript/nodejs/modules/proto/proto.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","proto","args","arguments","length","parent","init","noop","prototypeBuilder","namePointer","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","indexOf","normalizeErrorObject","parentIsFunction","prototypeName","prototype","name","ProtoObjectFactory","namedFunction","x","F","result","apply","protoUndefined","undefined","constructor","n","addProperty","Object","hasOwnProperty","ErrorObject","NormalizedError","tmp","message","defineProperty","get","stack","IntermediateInheritor","factoryObject","property","info","getOwnPropertyDescriptor","e","fn","Function"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAAH,GACA,gBAAAC,SACAA,QAAA,MAAAD,IAEAD,EAAA,MAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,GEtDf,YAMA,SAAAc,KACA,GAAAC,GAAAC,SAEA,OAAAD,EAAAE,OACA,GAAAC,IAAsBC,KAAAC,GACtBC,EAAAN,EAAA,OAGA,IAAAG,GAAAH,EAAA,GACAM,EAAAN,EAAA,EAIA,IAAAO,KACA,OAAAC,MAAAC,UAAAC,WAAAC,eAAAC,YAAAC,UAAAC,UAAAC,QAAAZ,KACAA,EAAAa,EAAAb,EAAAI,GAIA,IAAAU,GAAA,oBAEAX,GAAAY,GADAD,EACAd,EAAAe,GAEAf,CAIA,IAAAgB,GAAA,GAAAb,GAAAH,EACAI,GAAAa,KAAAD,EAAAC,IAEA,IAAAC,GAAAC,EAAAH,EAAAC,KAAA,WACA,GAAAG,GAAA,GAAAC,EAEA,IAAAL,EAAAf,GAAA,CACA,GAAAqB,GAAAN,EAAAf,GAAAsB,MAAAH,EAAAtB,UACA,OAAAwB,KAAA1B,EAAA4B,GACAC,EACAH,IAAAG,EACAH,EAEAF,EAEA,MAAAA,IAIAJ,GAAAU,YAAAR,GAIAF,EAAAf,IAAAa,IACAE,EAAAf,GAAA,WACAD,EAAAuB,MAAAtC,KAAAa,YAKA,IAAAuB,GAAA,YACAA,GAAAN,GAAAC,CAGA,QAAAW,KAAAX,GACAY,EAAAV,EAAAF,EAAAW,EAIA,QAAAA,KAAA3B,GACA6B,OAAAC,eAAAtC,KAAAQ,EAAA2B,IAAAT,EAAAS,KAAAF,GACAG,EAAAV,EAAAlB,EAAA2B,EAOA,OAHAT,GAAAlB,SACAkB,EAAAH,GAAAC,EAEAE,EAOA,QAAAL,GAAAkB,EAAA3B,GACA,QAAA4B,KACA,GAAAC,GAAA,GAAAF,GAAAjC,UAAA,GAcA,OAbAmC,GAAAhB,KAAAb,EAAAa,KAEAhC,KAAAiD,QAAAD,EAAAC,QACAL,OAAAM,eACAN,OAAAM,eAAAlD,KAAA,SACAmD,IAAA,WACA,MAAAH,GAAAI,SAIApD,KAAAoD,MAAAJ,EAAAI,MAGApD,KAGA,GAAAqD,GAAA,YAIA,OAHAA,GAAAtB,UAAAe,EAAAf,UACAgB,EAAAhB,UAAA,GAAAsB,GAEAN,EAGA,QAAAJ,GAAAW,EAAAvB,EAAAwB,GACA,IACA,GAAAC,GAAAZ,OAAAa,yBAAA1B,EAAAwB,EACAC,GAAAL,MAAAX,GAAAgB,EAAAL,MAAAX,GAAAI,OAAAM,iBAAAV,EACAI,OAAAM,eAAAI,EAAAC,EAAAC,GAEAF,EAAAC,GAAAxB,EAAAwB,GAEK,MAAAG,KAML,QAAAxB,GAAAF,EAAA2B,GACA,MAAA3B,KAAAQ,EACA,GAAAoB,UAAA,KACA,mBAAA5B,EAAA,wCACA2B,GAEAA,EAnIA,IAEAnB,GAFAvB,EAAA,aAEAa,EAAA,YAAAS,EAAA,YAAAvB,EAAA,YAAkG6B,eA+ElGlC,EAAA4B,MAEA1C,EAAAD,QAAAe","file":"proto.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"proto\"] = factory();\n\telse\n\t\troot[\"proto\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"proto\"] = factory();\n\telse\n\t\troot[\"proto\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\t\r\n\tvar noop = function() {}\r\n\t\r\n\tvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\n\tfunction proto() {\r\n\t    var args = arguments // minifiable variables\r\n\t\r\n\t    if(args.length == 1) {\r\n\t        var parent = {init: noop}   // set noop init so that every parent has an init\r\n\t        var prototypeBuilder = args[0]\r\n\t\r\n\t    } else { // length == 2\r\n\t        var parent = args[0]\r\n\t        var prototypeBuilder = args[1]\r\n\t    }\r\n\t\r\n\t    // special handling for Error objects\r\n\t    var namePointer = {}    // name used only for Error Objects\r\n\t    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n\t        parent = normalizeErrorObject(parent, namePointer)\r\n\t    }\r\n\t\r\n\t    // set up the parent into the prototype chain if a parent is passed\r\n\t    var parentIsFunction = typeof(parent) === \"function\"\r\n\t    if(parentIsFunction) {\r\n\t        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n\t    } else {\r\n\t        prototypeBuilder[prototypeName] = parent\r\n\t    }\r\n\t\r\n\t    // the prototype that will be used to make instances\r\n\t    var prototype = new prototypeBuilder(parent)\r\n\t    namePointer.name = prototype.name\r\n\t\r\n\t    var ProtoObjectFactory = namedFunction(prototype.name, function() {     // result object factory\r\n\t        var x = new F()          // empty object\r\n\t\r\n\t        if(prototype[init]) {\r\n\t            var result = prototype[init].apply(x, arguments)    // populate object via the constructor\r\n\t            if(result === proto[protoUndefined])\r\n\t                return undefined\r\n\t            else if(result !== undefined)\r\n\t                return result\r\n\t            else\r\n\t                return x\r\n\t        } else {\r\n\t            return x\r\n\t        }\r\n\t    })\r\n\t\r\n\t    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\t\r\n\t\r\n\t    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n\t    if(!prototype[init] && parentIsFunction) {\r\n\t        prototype[init] = function() {\r\n\t            parent.apply(this, arguments)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // constructor for empty object which will be populated via the constructor\r\n\t    var F = function() {}\r\n\t        F[prototypeName] = prototype    // set the prototype for created instances\r\n\t\r\n\t    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n\t    for(var n in prototype) {\r\n\t        addProperty(ProtoObjectFactory, prototype, n)\r\n\t    }\r\n\t\r\n\t    // add properties from parent that don't exist in the static class object yet\r\n\t    for(var n in parent) {\r\n\t        if(Object.hasOwnProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n\t            addProperty(ProtoObjectFactory, parent, n)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n\t    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\t\r\n\t    return ProtoObjectFactory;\r\n\t}\r\n\t\r\n\tproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\t\r\n\tmodule.exports = proto\r\n\t\r\n\tfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n\t    function NormalizedError() {\r\n\t        var tmp = new ErrorObject(arguments[0])\r\n\t        tmp.name = namePointer.name\r\n\t\r\n\t        this.message = tmp.message\r\n\t        if(Object.defineProperty) {\r\n\t            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n\t                get: function() {\r\n\t                    return tmp.stack\r\n\t                }\r\n\t            })\r\n\t        } else {\r\n\t            this.stack = tmp.stack\r\n\t        }\r\n\t\r\n\t        return this\r\n\t    }\r\n\t\r\n\t    var IntermediateInheritor = function() {}\r\n\t        IntermediateInheritor.prototype = ErrorObject.prototype\r\n\t    NormalizedError.prototype = new IntermediateInheritor()\r\n\t\r\n\t    return NormalizedError\r\n\t}\r\n\t\r\n\tfunction addProperty(factoryObject, prototype, property) {\r\n\t    try {\r\n\t        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n\t        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n\t            Object.defineProperty(factoryObject, property, info)\r\n\t        } else {\r\n\t            factoryObject[property] = prototype[property]\r\n\t        }\r\n\t    } catch(e) {\r\n\t        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n\t    }\r\n\t}\r\n\t\r\n\t// returns the function named with the passed name\r\n\tfunction namedFunction(name, fn) {\r\n\t    if(name !== undefined) {\r\n\t        return new Function('fn',\r\n\t            \"return function \" + name + \"(){ return fn.apply(this,arguments)}\"\r\n\t        )(fn)\r\n\t    } else {\r\n\t        return fn\r\n\t    }\r\n\t\r\n\t}\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** proto.umd.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 41a096fe40a15f5337f5\n **/","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}   // set noop init so that every parent has an init\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    var ProtoObjectFactory = namedFunction(prototype.name, function() {     // result object factory\r\n        var x = new F()          // empty object\r\n\r\n        if(prototype[init]) {\r\n            var result = prototype[init].apply(x, arguments)    // populate object via the constructor\r\n            if(result === proto[protoUndefined])\r\n                return undefined\r\n            else if(result !== undefined)\r\n                return result\r\n            else\r\n                return x\r\n        } else {\r\n            return x\r\n        }\r\n    })\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(Object.hasOwnProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                }\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\r\n\r\n// returns the function named with the passed name\r\nfunction namedFunction(name, fn) {\r\n    if(name !== undefined) {\r\n        return new Function('fn',\r\n            \"return function \" + name + \"(){ return fn.apply(this,arguments)}\"\r\n        )(fn)\r\n    } else {\r\n        return fn\r\n    }\r\n\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/proto/proto.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}